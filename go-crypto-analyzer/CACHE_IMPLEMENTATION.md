# 缓存功能实现说明

## 概述

我们已经成功实现了智能缓存机制，可以显著减少API调用次数，提高程序响应速度。

## 实现细节

### 1. 缓存架构

```
pkg/cache/cache.go
├── 内存缓存 (map[string]*CachedData)
├── 文件缓存 (.cache/*.json)
└── TTL机制 (可配置过期时间)
```

### 2. 核心功能

#### 数据结构
```go
type CachedData struct {
    Symbol    string         // 交易对
    Interval  string         // 时间间隔
    Data      []types.OHLCV  // K线数据
    UpdatedAt time.Time      // 更新时间
}
```

#### 主要方法
- `Get()`: 获取缓存数据（先内存后文件）
- `Set()`: 设置缓存数据（内存+异步写文件）
- `Update()`: 增量更新（智能合并去重）
- `Clear()`: 清除特定缓存
- `ClearAll()`: 清除所有缓存

### 3. CachedFetcher

`pkg/data/cached_fetcher.go` 提供了透明的缓存层：

```go
// 使用示例
fetcher := data.NewCachedFetcher(baseFetcher, ".cache", 5*time.Minute)
```

#### 智能策略
1. **首次请求**: 完整获取并缓存
2. **后续请求**: 
   - 检查缓存是否过期
   - 计算需要的新数据量
   - 只获取增量数据
   - 自动合并并去重

### 4. 命令行集成

新增的命令行参数：
```bash
--cache         # 启用缓存（默认）
--no-cache      # 禁用缓存
--cache-dir     # 缓存目录（默认 .cache）
--cache-ttl     # 有效期（默认 5分钟）
--clear-cache   # 清除所有缓存
```

## 使用效果

### 第一次运行
```
📥 首次获取数据，请求 100 根K线...
💾 已缓存 100 根K线数据
```

### 后续运行（5分钟内）
```
⚡ 使用缓存数据（最新: 01-02 15:04）
```

### 增量更新
```
🔄 增量更新：获取最新 50 根K线...
✅ 更新成功，新增 10 根K线
```

## 性能提升

1. **减少API调用**: 
   - 首次: 1次完整请求
   - 后续: 仅获取新数据或直接使用缓存

2. **响应速度**:
   - 无缓存: 1-3秒（取决于网络）
   - 有缓存: <100ms

3. **数据完整性**:
   - 自动去重
   - 时间排序
   - 最多保留1000条记录

## 注意事项

1. **缓存文件位置**: `.cache/[symbol]_[interval].json`
2. **内存占用**: 每个交易对约占用 1-2MB
3. **并发安全**: 使用读写锁保护
4. **自动清理**: 超过1000条自动截断旧数据

## 故障处理

- 文件读取失败: 自动降级到API请求
- API请求失败: 返回缓存数据（如果有）
- 缓存过期: 自动更新

## 未来优化

1. 支持压缩存储
2. 添加缓存预热功能
3. 实现分布式缓存
4. 添加缓存统计面板